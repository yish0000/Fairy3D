Xcode疑惑

std::string  绝对不要  str[n] = ‘\0’类似的代码，因为string的长度没有因之发生改变

―――――――――――――――――――――――

检查文件包系统！
注意：文件包最大为4G，超过这个大小，要分割成两个文件
限定单个文件的最大尺寸。

小内存分配策略优化！ 

内存管理器问题：
1. 内存记录哈希表错误
2. STL分配内存使用了全局new, 当全局变量中使用stl容器时，易引起错误。
3. 内存分配记录占用内存过高，应削减文件名长度，如只记录文件名字
4. 全局对象的析构顺序问题。全局STL容器析构时，FMemTracker早就被销毁了。

各个模块的内存占用情况
Common库：
1. 内存管理系统：
  1). FMemTracker::SimpleHashTable  ->  256KB
  2). 

FPS杀手:
1. 循环与判断过多。
2. 频繁更改渲染状态。

写程序要注意判断任何可能的结果，防止程序崩溃！！！！！

缓冲区溢出:
1. 做字符串运算时应该用安全的函数，杜绝strcpy()这类函数的出现。

sscanf函数 %d一定要对应四字节的类型！！

memcpy的时间复杂度是O(N)

注意下面两个工具:
Lint和BoundsChecker

如果有个BUG只在Release模式出现，而在Debug模式却没有。
1.大多数情况是忘了初始化一些变量，找出这种BUG的最好办
法是运行BoundsChecker一类的运行时分析器。
2.还有可能是由某个特殊的优化选项或者项目设置引起的BUG。
如果怀疑此，可以一点一点的修改项目设置，使之接近DEBUG
模式，直到BUG消失，一旦找出引起BUG的位置，则OK了。

强制类型转换运算符：C++有四种强制类型转换符，分别是dynamic_cast，const_cast，static_cast，reinterpret_cast。其中dynamic_cast与运行时类型转换密切相关，在这里我们先介绍dynamic_cast，其他三种在后面介绍。
6.1、dynamic_cast强制转换运算符：该转换符用于将一个指向派生类的基类指针或引用转换为派生类的指针或引用，注意dynamic_cast转换符只能用于含有虚函数的类，其表达式为dynamic_cast<类型>(表达式)，其中的类型是指把表达式要转换成的目标类型，比如含有虚函数的基类B和从基类B派生出的派生类D，则B *pb; D *pd, md;  pb=&md; pd=dynamic<D*>(pb); 最后一条语句表示把指向派生类D的基类指针pb转换为派生类D的指针，然后将这个指针赋给派生类D的指针pd，有人可能会觉得这样做没有意义，既然指针pd要指向派生类为什么不pd=&md;这样做更直接呢？有些时候我们需要强制转换，比如如果指向派生类的基类指针B想访问派生类D中的除虚函数之外的成员时就需要把该指针转换为指向派生类D的指针，以达到访问派生类D中特有的成员的目的，比如派生类D中含有特有的成员函数g()，这时可以这样来访问该成员dynamic_cast<D*>(pb)->g();因为dynamic_cast转换后的结果是一个指向派生类的指针，所以可以这样访问派生类中特有的成员。但是该语句不影响原来的指针的类型，即基类指针pb仍然是指向基类B的。如果单独使用该指针仍然不能访问派生类中特有的成员。一般情况下不推见这样使用dynamic_cast转换符，因为dynamic_cast的转换并不会总是成功的，具体情况在后面介绍。
6.2、dynamic_cast的注意事项：dynamic_cast转换符只能用于指针或者引用。dynamic_cast转换符只能用于含有虚函数的类。dynamic_cast转换操作符在执行类型转换时首先将检查能否成功转换，如果能成功转换则转换之，如果转换失败，如果是指针则反回一个0值，如果是转换的是引用，则抛出一个bad_cast异常，所以在使用dynamic_cast转换之间应使用if语句对其转换成功与否进行测试，比如pd=dynamic_cast<D*>(pb); if(pd){…}else{…}，或者这样测试if(dynamic_cast<D*>(pb)){…}else{…}。
6.3、const_cast操作符：其表达式为const_cast<类型>(表达式)，其中类型指要把表达式转换为的目标类型。该操作符用于改变const和volatile，const_cast最常用的用途就是删除const属性，如果某个变量在大多数时候是常量，而在某个时候又是需要修改的，这时就可以使用const_cast操作符了。const_cast操作符不能改变类型的其他方面，他只能改变const或volatile，即const_cast不能把int改变为double，但可以把const int改变为int。const_cast只能用于指针或引用。const_cast的用法举例比如：int a=3; const int *b=&a; int* c;  c=const_cast<int*>(b); *c=4; cout<<a<<*c;这时输出两个4，如果不使用const_cast转换符则常量指针*c的值是不能改变的，在这里使用const_cast操作符，通过指针b就能改变常量指针和变量a的值。
6.4、static_cast操作符：该操作符用于非多态类型的转换，任何标准转换都可以使用他，即static_cast可以把int转换为double，但不能把两个不相关的类对象进行转换，比如类A不能转换为一个不相关的类B类型。static_cast本质上是传统c语言强制转换的替代品。
6.5、reinterpret_cast操作符：
reinterpret_cast运算符是用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数（expressoin）有完全相同的比特位。
该操作符用于将一种类型转换为另一种不同的类型，比如可以把一个整型转换为一个指针，或把一个指针转换为一个整型，因此使用该操作符的危险性较高，一般不应使用该操作符。

--------------------------------------------------------------------------

(Debug Assert错误)

通常是由于，在一个线程中分配内存，
在另一个线程中释放内存时引发这个错误。
例如：一个应用程序调用一个DLL时，在应用程序中
      分配的内存，在DLL中释放，就会引发错误。

解决办法：
    1. 将DLL程序，和App程序的CodeGeneration改为Multithread-Dll.
    2. 在同一个线程内申请和释放内存.

当向DLL的函数中传递对象参数时，构造对象是在EXE中，然后再推入DLL函数的堆栈，
所以DLL函数结束时会销毁对象，释放内存。所以引发了DEBUG assert错误。解决的方法
是，传递对象的指针或者CONST引用。

使用字符数组时一定要注意可能会引起缓冲区溢出。